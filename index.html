<!DOCTYPE html>
<html lang="en">
 
<head>
<meta charset="UTF-8" />
<title>codingpreprocessor</title>
<script src="https://cdn.ckeditor.com/ckeditor5/39.0.1/classic/ckeditor.js"></script>
<style>
    *,
    *::before,
    *::after {
    box-sizing: border-box;
    }
    body {
    margin: 0;
    background: #f8f9fa;
    font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    font-size: 16px;
    color: #333;
    display: flex;
    justify-content: center;
    padding: 40px 15px;
    }
 
    .container {
    width: 100%;
    max-width: 720px;
    background: #fff;
    box-shadow: 0 4px 12px rgb(0 0 0 / 0.1);
    border-radius: 8px;
    padding: 30px 35px 40px;
    box-sizing: border-box;
    }
 
    h2 {
    margin-top: 0;
    margin-bottom: 15px;
    font-weight: 600;
    text-align: center;
    color: #222;
    letter-spacing: 0.04em;
    }
 
    .form-group {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    gap: 20px;
    margin-bottom: 25px;
    }
 
    .form-group-column {
    flex: 1 1 48%;
    display: flex;
    flex-direction: column;
    }
 
    label {
    font-weight: 600;
    margin-bottom: 8px;
    color: #555;
    font-size: 0.95rem;
    user-select: none;
    }
 
    select,
    input[type="number"],
    input[type="color"] {
    padding: 8px 12px;
    font-size: 1rem;
    border-radius: 6px;
    border: 1.5px solid #ccc;
    background-color: #fff;
    color: #333;
    cursor: pointer;
    transition: border-color 0.2s, box-shadow 0.2s;
    box-sizing: border-box;
    width: 100%;
    }
 
    input[type="number"] {
    outline-offset: 2px;
    }
 
    input[type="color"] {
    height: 40px;
    padding: 0;
    }
 
    select:hover,
    input[type="color"]:hover,
    input[type="number"]:hover {
    border-color: #007bff;
    box-shadow: 0 0 5px rgba(0, 123, 255, 0.3);
    }
 
    select:focus,
    input[type="color"]:focus,
    input[type="number"]:focus {
    border-color: #0056b3;
    box-shadow: 0 0 8px rgba(0, 86, 179, 0.5);
    }
 
    #editor {
    border: 1px solid #bbb;
    min-height: 150px;
    border-radius: 6px;
    font-size: 1rem;
    margin-bottom: 30px;
    box-sizing: border-box;
    }
 
    #output {
    font-family: 'Courier New', Courier, monospace;
    font-size: 11pt;
    white-space: pre-wrap;
    background-color: #f4f6f8;
    border: 1.5px solid #ddd;
    padding: 15px 18px;
    min-height: 200px;
    border-radius: 6px;
    resize: vertical;
    color: #222;
    line-height: 1.4;
    user-select: all;
    width: 100%;
    }
 
    button {
    cursor: pointer;
    padding: 10px 18px;
    font-size: 1rem;
    font-weight: 600;
    border: none;
    border-radius: 6px;
    background-color: #007bff;
    color: #fff;
    transition: background-color 0.3s ease, box-shadow 0.3s ease;
    display: block;
    margin-bottom: 15px;
    width: 100%;
    max-width: 160px;
    user-select: none;
    }
 
    button:hover {
    background-color: #0056b3;
    box-shadow: 0 0 8px rgba(0, 86, 179, 0.5);
    }
 
    button:active {
    background-color: #003f7f;
    }
 
    @media (max-width: 560px) {
    .container {
        padding: 25px 20px 30px;
    }
 
    #editor,
    #output {
        font-size: 14px;
    }
 
    button {
        max-width: 100%;
    }
 
    .form-group-column {
        flex: 1 1 100%;
    }
    }
 
    .note {
    font-size: 0.9rem;
    color: #666;
    text-align: center;
    margin-bottom: 20px;
    }
 
</style>
</head>
 
<body>
  <div class="container">
    <h2>Coding Pre-processor</h2>
 
    <!-- Controls Section -->
    <div class="form-group">
      <div class="form-group-column">
        <label for="languageSelector">Select Language</label>
        <select id="languageSelector" onchange="renderOutput()">
          <option value="en">English</option>
          <option value="th">Thai</option>
          <option value="zh-cn">Chinese (Simplified)</option>
          <option value="zh-tw">Chinese (Traditional)</option>
          <option value="ko">Korean</option>
          <option value="ja">Japanese</option>
        </select>
      </div>
 
      <!-- <div class="form-group-column">
        <label for="fontSizeInput">Font size (pt):</label>
        <input type="number" id="fontSizeInput" min="10.5" max="15" value="10.5" step="0.1" />
      </div>
  -->
      <div class="form-group-column">
        <label for="borderSizeSelector">Border Size (px)</label>
        <select id="borderSizeSelector" onchange="updateTableBorders()">
          <option value="0">0</option>
          <option value="1" selected>1</option>
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4</option>
          <option value="5">5</option>
        </select>
      </div>
 
      <div class="form-group-column">
        <label for="tableCellColor">Cell Color</label>
        <input type="color" id="tableCellColor" />
      </div>
    </div>
 
    <!-- Editor -->
    <textarea id="editor" placeholder="Paste or type content here..."></textarea>
 
    <!-- Output HTML -->
    <h2>Generated HTML Code</h2>
    <button onclick="copyHTML()">Copy HTML Code</button>
    <textarea id="output" readonly></textarea>
 
    <!-- Preview -->
    <h2>Preview</h2>
    <p class="note">Click a table cell below to change its background color</p>
    <div id="preview" style="border: 1.5px solid #ccc; padding: 15px; border-radius: 6px; min-height: 150px; background: #fff; overflow: auto;"></div>
 
    <!-- Hidden color picker for cell color editing -->
    <input type="color" id="cellColorPicker" style="display: none;" />
    <button id="applyColorBtn" style="display: none;">Apply Color</button>
  </div>
    <script>
    let editorInstance;
let selectedCell = null;  // Track currently selected cell in preview
 
ClassicEditor
  .create(document.querySelector('#editor'), {
    toolbar: ['bold', 'italic', 'underline','|','bulletedList', 'numberedList', 'link', 'insertTable', '|','undo', 'redo','|', 'outdent', 'indent']
  })
  .then(editor => {
    editorInstance = editor;
    editor.model.document.on('change:data', () => {
      renderOutput();
    });
  })
  .catch(error => {
    console.error(error);
  });
 
function formatHTML(html) {
  const tab = '  ';
  let result = '';
  let indent = '';
 
  html.split(/>\s*</).forEach((element) => {
    element = element.trim();
    if (!element) return;
 
    if (element.startsWith('/')) indent = indent.slice(0, -tab.length);
    result += indent + '<' + element + '>\n';
    if (
      element.match(/^<?\w[^>]*[^\/]$/) &&
      !element.startsWith('br') &&
      !element.startsWith('hr') &&
      !element.startsWith('/')
    ) {
      indent += tab;
    }
  });
 
  return result.trim();
}
 
function renderOutput() {
  const content = editorInstance.getData();
 
  const fontMap = {
    "en": "'Segoe UI', Verdana, Geneva, Sans-serif",
    "th": "'Leelawadee', Arial, sans-serif",
    "zh-cn": "'Microsoft Yahei UI', Arial, sans-serif",
    "zh-tw": "'Microsoft JhengHei UI', Arial, sans-serif",
    "ko": "'Malgun Gothic', Arial, sans-serif",
    "ja": "'Yu Gothic UI', sans-serif"
  };
 
  const selectedLang = document.getElementById("languageSelector").value;
  const selectedFont = fontMap[selectedLang] || "'Segoe UI'";
 
  const style = `style="font-size: 13.5pt; font-family: ${selectedFont};"`;
  let styled = content
    .replace(/<p>/g, `<p ${style}>`)
    .replace(/<ul>/g, `<ul ${style}>`)
    .replace(/<li>/g, `<li ${style}>`)
    .replace(/<i>/g, `<em>`)
    .replace(/<\/i>/g, `</em>`)
    .replace(/<br>/g, `<br/>`);
 
  styled = styled
    .split('\n')
    .filter(line => line.trim() !== '')
    .join('\n')
    .replace(/\s{2,}/g, ' ')
    .replace(/&nbsp;\s+/g, '')
    .replace(/\s+&nbsp;/g, '')
    .replace(/<p[^>]*>(&nbsp;|\s)*<\/p>/gi, '')
    .trim();
 
  const formatted = formatHTML(styled);
  const trimmed = formatted.substring(1, formatted.length - 1);
  document.getElementById('output').textContent = trimmed;
 
  // Update preview panel
  const preview = document.getElementById('preview');
  preview.innerHTML = content;
 
  // Update table borders in preview
  updateTableBordersInPreview();
 
  // Attach cell click listeners
  attachCellClickListeners();
 
}
 
function copyHTML() {
  const textarea = document.getElementById("output");
  const content = textarea.value.trim();
 
  if (!content) {
    alert("There is no generated HTML code to copy.");
    return;
  }
 
  textarea.select();
  textarea.setSelectionRange(0, 99999);
  document.execCommand("copy");
  alert("HTML code copied to clipboard!");
}
 
function updateTableBorders() {
  let borderSize = document.getElementById('borderSizeSelector').value;
 
  let content = editorInstance.getData();
  const parser = new DOMParser();
  const doc = parser.parseFromString(content, 'text/html');
 
  const tables = doc.querySelectorAll('table');
  if (tables.length === 0) return;
 
  tables.forEach(table => {
    table.style.borderCollapse = 'collapse';
    table.style.border = `${borderSize}px solid black`;
    table.querySelectorAll('td, th').forEach(cell => {
      cell.style.border = `${borderSize}px solid black`;
    });
  });
 
  const serializer = new XMLSerializer();
  let newHTML = serializer.serializeToString(doc.body);
  newHTML = newHTML.replace(/^<body>([\s\S]*)<\/body>$/i, '$1');
 
  editorInstance.setData(newHTML);
}
 
function updateTableBordersInPreview() {
  let borderSize = document.getElementById('borderSizeSelector').value;
  const preview = document.getElementById('preview');
 
  const tables = preview.querySelectorAll('table');
  tables.forEach(table => {
    table.style.borderCollapse = 'collapse';
    table.style.border = `${borderSize}px solid black`;
    table.querySelectorAll('td, th').forEach(cell => {
      cell.style.border = `${borderSize}px solid black`;
    });
  });
}
 
// Attach click listeners to all cells in preview
function attachCellClickListeners() {
  const preview = document.getElementById('preview');
  const cells = preview.querySelectorAll('td, th');
 
  // Remove previous listeners by cloning nodes (simple way to reset)
  cells.forEach(cell => {
    cell.replaceWith(cell.cloneNode(true));
  });
 
  // Re-query cells after clone
  const newCells = preview.querySelectorAll('td, th');
  newCells.forEach(cell => {
    cell.addEventListener('click', () => {
      selectCell(cell);
    });
  });
 
  // Reset selected cell UI
  selectedCell = null;
  hideColorPicker();
}
 
function selectCell(cell) {
  // Remove highlight from previous
  if (selectedCell) {
    selectedCell.style.outline = '';
  }
 
  selectedCell = cell;
  selectedCell.style.outline = '3px solid #007bff'; // highlight selected cell
 
  showColorPicker(selectedCell.style.backgroundColor || '#ffffff');
}
 
function showColorPicker(currentColor) {
  // Create or get the floating color picker container
  let container = document.getElementById('floatingColorPicker');
  if (!container) {
    container = document.createElement('div');
    container.id = 'floatingColorPicker';
    container.style.position = 'fixed';
    container.style.background = '#fff';
    container.style.border = '1px solid #ccc';
    container.style.padding = '8px';
    container.style.borderRadius = '6px';
    container.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';
    container.style.zIndex = '9999';
 
    // Color input
    const colorInput = document.createElement('input');
    colorInput.type = 'color';
    colorInput.id = 'previewCellColorPicker';
    container.appendChild(colorInput);
 
    // Apply button
    const applyBtn = document.createElement('button');
    applyBtn.textContent = 'Apply Color';
    applyBtn.style.marginLeft = '10px';
    applyBtn.style.cursor = 'pointer';
    applyBtn.style.padding = '6px 12px';
    applyBtn.style.borderRadius = '4px';
    applyBtn.style.border = 'none';
    applyBtn.style.backgroundColor = '#007bff';
    applyBtn.style.color = '#fff';
    applyBtn.addEventListener('click', applyColorToSelectedCell);
    container.appendChild(applyBtn);
 
    document.body.appendChild(container);
  }
 
  const colorInput = document.getElementById('previewCellColorPicker');
  colorInput.value = rgbToHex(currentColor);
 
  // Position picker near selected cell
  const rect = selectedCell.getBoundingClientRect();
  container.style.top = `${rect.bottom + window.scrollY + 5}px`;
  container.style.left = `${rect.left + window.scrollX}px`;
  container.style.display = 'flex';
}
 
// Hide the color picker
function hideColorPicker() {
  const container = document.getElementById('floatingColorPicker');
  if (container) {
    container.style.display = 'none';
  }
}
 
// Convert rgb() or rgba() to hex
function rgbToHex(rgb) {
  if (!rgb) return '#ffffff';
  if (rgb.startsWith('#')) return rgb;
 
  const rgbMatch = rgb.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)/);
  if (!rgbMatch) return '#ffffff';
 
  const r = parseInt(rgbMatch[1]).toString(16).padStart(2, '0');
  const g = parseInt(rgbMatch[2]).toString(16).padStart(2, '0');
  const b = parseInt(rgbMatch[3]).toString(16).padStart(2, '0');
 
  return `#${r}${g}${b}`;
}
 
function applyColorToSelectedCell() {
  if (!selectedCell) {
    alert('Please select a cell first.');
    return;
  }
 
  const colorInput = document.getElementById('previewCellColorPicker');
  const chosenColor = colorInput.value;
 
  // Apply color only to the selected cell
  selectedCell.style.backgroundColor = chosenColor;
 
  // Update the editor content with the new HTML from preview
  updateEditorContentFromPreview();
 
  // Refresh output and preview (listeners will be reattached)
  renderOutput();
}
 
// Update the editor data with current preview HTML
function updateEditorContentFromPreview() {
  const preview = document.getElementById('preview');
 
  // Clone preview so we don't modify actual DOM during serialization
  const clone = preview.cloneNode(true);
 
  // Remove the outline from the selected cell if present
  const outlinedCell = clone.querySelector('[style*="outline"]');
  if (outlinedCell) {
    outlinedCell.style.outline = '';
  }
 
  // Serialize innerHTML to set in editor
  const newHTML = clone.innerHTML;
 
  editorInstance.setData(newHTML);
}
 
</script>
 
</body>
</html>
 
 
